r"""
.. _coherent_vqls:

Coherent Variational Quantum Linear Solver
==========================================
*Author: Andrea Mari*

In this tutorial we propose and implement an algorithm that we call
*coherent variational quantum linear solver* (CVQLS). 
This is inspired by the VQLS proposed in Ref. [1], with an important difference: 
the matrix :math:`A` associated to the problem is physically 
applied as a probabilistic coherent operation. This approach as some advantages and
disadvantages and its practical convenience depends on experimental aspects 
and on the specific linear problem to be solved.


Introduction
------------

We first define the problem and the general structure of the CVQLS. 
As a second step, we consider a particular case and we solve it explicitly with PennyLane.

The problem
^^^^^^^^^^^

We are given a :math:`2^n \times 2^n` matrix :math:`A` which can be expressed as a linear
combination of :math:`L` unitary matrices :math:`A_0, A_1, \dots A_{L-1}`, i.e.,

.. math::

    A = \sum_{l=0}^{L-1} c_l A_l,

where :math:`c_l` are arbitrary complex numbers. Importantly, we assume that each of the
unitary components :math:`A_l` can be efficiently implemented with a quantum circuit
acting on :math:`n` qubits.

We are also given a normalized complex vector in the physical form of a quantum
state :math:`|b\rangle`, which can be generated by a unitary operation :math:`U`
applied to the ground state of :math:`n` qubits. , i.e.,

.. math::

    |b\rangle = U_b |0\rangle,

where again we assume that :math:`U_b` can be efficiently implemented with a quantum circuit.

The problem that we aim to solve is that of preparing a quantum state :math:`|x\rangle`, such that
:math:`A |x\rangle` is proportional to :math:`|b\rangle` or, equivalently, such that

.. math::

    |\Psi\rangle :=  \frac{A |x\rangle}{\sqrt{\langle x |A^\dagger A |x\rangle}} \approx |b\rangle.


Coherent Variational Quantum Linear Solver (CVQLS)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We approximate the solution :math:`|x\rangle` with a variational quantum
circuit, i.e., a unitary circuit :math:`V` depending on a finite number of classical real parameters
:math:`w = (w_0, w_1, \dots)`:

.. math::

    |x \rangle = V(w) |0\rangle.

The parameters should be optimized in order to maximize the overlap between the quantum states
:math:`|\Psi\rangle` and :math:`|b\rangle`. This suggests to define the following cost function:

.. math::

    C = 1- |\langle b | \Psi \rangle|^2,

such that its minimization with respect to the variational parameters should lead towards the problem solution.

The approach used in Ref. [1] is to decompose the cost function in terms of many expectation values associated to the
individual components :math:`A_l` of the problem matrix :math:`A`. For this reason, in the VQLS of Ref. [1],
the state vector proportional to :math:`A |x\rangle` is not physically prepared.
On the contrary, the idea presented in this tutorial is to physically implement the linear map :math:`A` as
a coherent probabilistic operation. This approach allows to prepare the state 
:math:`|\Psi\rangle :=  A |x\rangle/\sqrt{\langle x |A^\dagger A |x\rangle}` which can be used to estimate the
cost function of the problem in a more direct way.


Coherently applying :math:`A`
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Without loss of generality we can assume that the coefficients :math:`c=(c_1, c_2, \dots c_L)` appearing
in the definition of :math:`A` represent a positive and normalized probability distribution. i.e.

.. math::
    
    c_l \ge 0 \quad \forall l,  \qquad \sum_{l=0}^{L-1} c_l=1.

Indeed the complex phase of each coefficient :math:`c_l` can always be absorbed into the associated unitary :math:`A_l`, obtaining
in this way a list of positive coefficients. Moreover, since the linear problem is 
defined up to a constant scaling factor, we can also normalize the coefficients to get a probability distribution.

For simplicity, since we can always pad :math:`c` with additional zeros, we can also assume that :math:`L=2^m` for some positive integer :math:`m`.

Let us consider a unitary circuit :math:`U_c`, embedding the classical vector :math:`c` into the quantum state :math:`|c\rangle` of :math:`m` ancillary qubits:

.. math::

    |\sqrt{c} \rangle =  U_c |0\rangle = \sum_{l=0}^{L-1} \sqrt{c_l} | l \rangle,

where :math:`\{ |l\rangle \}` is the computational basis of the ancillary system.


Now, for each component :math:`A_l` of the problem matrix :math:`A`, we can define an associated controlled unitary operation :math:`CA_l`,
acting on the system and on the ancillary basis states as follows:

.. math::

    CA_l \, |j\rangle |l' \rangle  = 
    \Bigg\{
    \begin{array}{c}
    \left(A_l \otimes \mathbb{I}\right) \; |j\rangle |l \rangle \quad \; \mathrm{for}\; l'=l \\
    \qquad \qquad |j\rangle |l' \rangle  \quad \mathrm{for}\; l'\neq l 
    \end{array},

i.e., the unitary :math:`A_l` is applied only when the ancillary system is in the corresponding basis state :math:`|l\rangle`.

A natural generalization of the Hadamard test to :math:`m` ancillary qubits is the following protocol, originally proposed
in Ref. [2]:

1. Prepare all qubits in the ground state.
2. Apply :math:`U_c` to the ancillary qubits.
3. Apply all the controlled unitaries :math:`CA_l` for all values of :math:`l`.
4. Apply :math:`U_c^\dagger` to the ancillary qubits.
5. Measure the ancillary qubits in the computational basis.
6. If the outcome of the measurement is the ground state, the state of the system collapses to
   :math:`|\Psi\rangle :=  A |x\rangle/\sqrt{\langle x |A^\dagger A |x\rangle}`.
   If the outcome is not the ground state, the experiment should be repeated.


Estimating the cost function
>>>>>>>>>>>>>>>>>>>>>>>>>>>>

From a technical point of view, the previous steps represent the most difficult part of the algorithm. 
Once we have at our disposal the quantum system prepared in the state :math:`|\Psi\rangle`,
it is very easy to compute the cost function.
Indeed one could simply continue the previous protocol with the following two steps:

7. Apply :math:`U_b^\dagger` to the system.
8. Measure the system in the computational basis. The probability of measuring it
   in the ground state (given the ancillary qubits measured in their ground state),
   is :math:`|\langle 0 | U_b^\dagger |\Psi \rangle|^2 = |\langle b | \Psi \rangle|^2`.

Therefore, by repeating the full experiment with the same fixed settings, one can directly estimate
the cost function of the problem.

Importantly, the operations of steps 6 and 7 commute. Therefore all the measurements can be
delayed at the end of the quantum circuit, making the structure of the experiment more straightforward.  




A simple example
^^^^^^^^^^^^^^^^

In this tutorial we apply the previous theory to the following simple example 
based on a system of 3 qubits, which was also considered in Ref. [1] and in one of our previous tutorials (VQLS):

.. math::
        \begin{align}
        A  &=  c_0 A_0 + c_1 A_1 + c_2 A_2 = \mathbb{I} + 0.2 X_0 Z_1 + 0.2 X_0, \\
        \\
        |b\rangle &= U_b |0 \rangle = H_0  H_1  H_2 |0\rangle,
        \end{align}

where :math:`Z_j, X_j, H_j` represent the Pauli :math:`Z`, Pauli :math:`X` and Hadamard gates applied to the qubit with index :math:`j`.

This problem is computationally quite easy since a single layer of local rotations is enough to generate the
solution state, i.e., we can use the following simple ansatz:

.. math::
        |x\rangle = V(w) |0\rangle = \Big [  R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2) \Big ]  H_0  H_1  H_2 |0\rangle.


In the code presented below we solve this particular problem, by following the general scheme of the CVQLS previously discussed.
Eventually we will compare the quantum solution with the classical one.

"""



##############################################################################
# General setup
# ------------------------
# This Python code requires *PennyLane* and the plotting library *matplotlib*.

# Pennylane
import pennylane as qml
from pennylane import numpy as np

# Plotting
import matplotlib.pyplot as plt

##############################################################################
# Setting of the main hyper-parameters of the model
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

n_qubits = 3                # Number of system qubits.
m = 2                       # Number of ancillary qubits
n_shots = 10 ** 6           # Number of quantum measurements.
tot_qubits = n_qubits + m   # Addition of two ancillary qubits.
ancilla_idx = n_qubits      # Index of the first ancillary qubit.
steps = 1                   # Number of optimization steps.
eta = 0.8                   # Learning rate.
q_delta = 0.001             # Initial spread of random quantum weights.
rng_seed = 0                # Seed for random number generator.


##############################################################################
# Circuits of the quantum linear problem
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

##############################################################################
# We now define the unitary operations associated to the simple example
# presented in the introduction.
#
# The coefficients of the linear combination are three positive numbers :math:`(1, 0.2, 0.2)`.
# So we can embed them in the state of  :math:`m=2` ancillary qubits by adding a final zero element and
# normalizing their sum:

c = np.array([1, 0.2, 0.2, 0])
c = c  / c .sum()


##############################################################################
# New we need to embed the square root of the probability distribution ``c`` into the amplitudes
# of the ancillary state.

def U_c():
    """Unitary matrix rotating the ground state of the ancillary qubits to |sqrt(c)> = U_c |0>."""
    # TO BE DONE. THIS IS A DRAFT.
    qml.RY(-np.arcsin(c[1]), wires=ancilla_idx)
    qml.RY(-np.arcsin(c[2]), wires=ancilla_idx + 1)

def U_c_dagger():
    """Adjoint of U_c."""
    # TO BE DONE. THIS IS A DRAFT.
    qml.RY(np.arcsin(c[1]), wires=ancilla_idx)
    qml.RY(np.arcsin(c[2]), wires=ancilla_idx + 1)

##############################################################################
# The circuit for preparing the problem vector :math:`|b\rangle` is very simple:

def U_b():
    """Unitary matrix rotating the system ground state to the problem vector |b> = U_b |0>."""
    for idx in range(n_qubits):
        qml.Hadamard(wires=idx)

##############################################################################
# We are left to define the controlled-unitaries :math:`CA_l`, which should act
# as :math:`A_l` on the system qubits whenever the ancillary ones are in the state
# :math:`|l\rangle`. In our case this simply corresponds to conditioning :math:`A_1` and
# :math:`A_2` to the first and second ancillary qubits respectively.

def CA(l):
    """Controlled versions of the unitary components A_l of the problem matrix A."""  
    
    if l == 1:
        qml.CNOT(wires=[ancilla_idx, 0])
        qml.CZ(wires=[ancilla_idx, 1])

    elif l == 2:
        qml.CNOT(wires=[ancilla_idx + 1, 0])
    
    # For all other values of "l", A_l = Identity.
    
    


##############################################################################
# Variational quantum circuit
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# What follows is the variational quantum circuit that should generate the solution
# state :math:`|x\rangle= V(w)|0\rangle`.
#
# The first layer of the circuit is a product of Hadamard gates preparing a
# balanced superposition of all basis states.
#
# After that, we apply a very simple variational ansatz
# which is just a single layer of qubit rotations
# :math:`R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2)`.
# For solving more complex problems, we suggest to use more expressive circuits as,
# e.g., the PennyLane template `pennylane.templates.layers.StronglyEntanglingLayers()`.


def variational_block(weights):
    """Variational circuit mapping the ground state |0> to the ansatz state |x>."""
    # We first prepare an equal superposition of all the states of the computational basis.
    for idx in range(n_qubits):
     qml.Hadamard(wires=idx)

    # A very minimal variational circuit.
    for idx, element in enumerate(weights):
        qml.RY(element, wires=idx)


##############################################################################
# Full quantum circuit
# --------------------
#
# We first initialize a PennyLane device with the ``default.qubit`` backend.
#
# As a second step, we define a PennyLane ``qnode`` object representing a model of the actual quantum computation.
#
# The circuit implements the CVQLS protocol presented in the introduction.

def full_circuit(weights):
    """Full quantum circuit necessary for the CVQLS protocol, without the final measurement."""
    # U_c applied to the ancillary qubits.
    U_c()

    # Variational circuit generating a guess for the solution vector |x>
    variational_block(weights)

    # Application of all controlled-unitaries CA_l associated to the problem matrix A.
    for l in range(2 ** m):
        CA(l)

    # Adjoint of U_c, applied to the ancillary qubits.
    U_c_dagger()


##############################################################################
# To measure the overlap of the ground state with the post-selected state, we
# use the Bayes' theorem:
# 
#.. math::
#
#   P
#

dev_full = qml.device("default.qubit", wires=tot_qubits)
@qml.qnode(dev_full)
def global_ground(weights):
    # Circuit gates
    full_circuit(weights)
    # Projector on the global ground state.
    P_zero = np.zeros((2 ** tot_qubits, 2 ** tot_qubits))
    P_zero[0, 0] = 1.0 
    return qml.expval(qml.Hermitian(P_zero, wires=range(tot_qubits)))

dev_partial = qml.device("default.qubit", wires=tot_qubits)
@qml.qnode(dev_partial)
def ancilla_ground(weights):
    # Circuit gates
    full_circuit(weights)
    # Projector on the ancilla ground state.
    P_zero = np.zeros((2 ** m, 2 ** m))
    P_zero[0, 0] = 1.0 
    return qml.expval(qml.Hermitian(P_zero, wires=range(n_qubits, tot_qubits)))



##############################################################################
# Variational optimization
# -----------------------------
#
# We first initialize the variational weights with random parameters (with a fixed seed).

np.random.seed(rng_seed)
w = q_delta * np.random.randn(n_qubits)

p_global_ground = global_ground(w)
p_ancilla_ground = ancilla_ground(w)
p_cond = p_global_ground / p_ancilla_ground
print("p_global_ground:", p_global_ground)
print("p_ancilla_ground:", p_ancilla_ground)
print("p_cond:", p_cond)



##############################################################################
# References
# ----------
#
# 1. Carlos Bravo-Prieto, Ryan LaRose, Marco Cerezo, Yigit Subasi, Lukasz Cincio, Patrick J. Coles.
#    "Variational Quantum Linear Solver: A Hybrid Algorithm for Linear Systems."
#    `arXiv:1909.05820 <https://arxiv.org/abs/1909.05820>`__, 2019.
# 
# 2. Robin Kothari.
#    "Efficient algorithms in quantum query complexity."
#    PhD thesis, University of Waterloo, 2014.
#
# 

