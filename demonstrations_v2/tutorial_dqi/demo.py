r"""Decoded Quantum Interferometry
==============================

Demonstrating quantum advantage is a long-sought goal by the quantum computing community. Clearly
demonstrating that a quantum algorithm can solve a practical computational task with an advantage
over classical algorithms remains an active area of research. Recently, a paper introduced an
algorithm called **Decoded quantum interferometry (DQI)** to tackle combinatorial optimization
problems [#Jordan2024]_. For a specific application involving approximating optimal polynomial fits, it
showed superior performance over existing classical counterparts. DQI takes a new approach; unlike
QAOA and adiabatic optimization, it doesn’t use Hamiltonians to connect the optimization to quantum
mechanics. Instead, it leverages quantum interference and transforms the optimization problem into a
decoding one.

In this demo, we will use DQI to solve the max-XORSAT problem implemented in PennyLane. While this
problem is simple and has not yet demonstrated quantum advantage, it clearly illustrates the
operational principles and underlying intuition of DQI. We will begin by introducing the problem and
the core principles of the algorithm, followed by a description of each algorithmic step and its
corresponding implementation.

The max-XORSAT problem
----------------------

The task of finding the best solution(s) from a large, finite set of possible candidates is known as
a combinatorial optimization problem, such as the traveling salesman problem. Mathematically, this
can be phrased as trying to maximize an objective function whose domain is large and discrete.

The max-XORSAT problem is a simple example of this, where we are given an :math:`m\times n` matrix
:math:`B` (with :math:`m>n`) and are required to find the :math:`n`-bit string :math:`\mathbf{x}`
that satifies the maximum number of constraints imposed by the :math:`m` linear mod-2 equations,
over :math:`\mathbb{F}_2`, :math:`B\mathbf{x}=\mathbf{v}`. Here, :math:`\mathbf{v}` is a vector of
dimension :math:`m` specified by the problem. Since this system of equations is over
:math:`\mathbb{F}_2`, the matrix and vectors only contain zeros and ones.

The objective function we are aiming to maximize is

.. math:: f(\mathbf{x})=\sum_{i=1}^{m}(-1)^{v_i+\mathbf{b_i}\cdot\mathbf{x}}.

Here, :math:`\mathbf{b_i}` is the :math:`i` row of matrix :math:`B`. You can verify that this
function represents the number of satisfied equations minus the number of unsatisfied ones by
considering that when the equation is satisfied, the exponent
:math:`v_i+\mathbf{b_i}\cdot\mathbf{x}` is always even, and that it is odd in the opposite case.

Now, let’s define the conditions for our specific max-XORSAT problem and visualize this objective
function. We’ll randomly sample bit strings :math:`\mathbf{x}` to plot the function’s landscape.
Later, we’ll use samples generated by the DQI algorithm and compare them to this initial plot to see
how well DQI performs.
"""

import pennylane as qml
import math
from pennylane import numpy as pnp
import matplotlib.pyplot as plt
import itertools

plt.style.use("pennylane.drawer.plot")
plt.rcParams.update({"font.size": 10, "font.family": "STIXGeneral", "mathtext.fontset": "cm"})

# Define parameters of max-XORSAT problem Bx=(mod2)v
B = pnp.array([[1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]])  # Matrix B
v = pnp.array([1, 0, 1, 0, 1])  # vector of constraints
m = B.shape[0]
n = B.shape[1]
B_T = B.T
n_samples = 2000


def objective_function(x):
    """Calculates objective function."""
    sum = 0
    for i in range(m):
        sum += (-1) ** (v[i] + pnp.dot(B[i, :], x))
    return sum


# Random sampling
f_x_array = []
f_x_array_random = [objective_function(pnp.random.randint(0, 2, size=n)) for i in range(n_samples)]

plt.figure(figsize=(3, 2))
plt.hist(f_x_array_random, bins=30, density=True)
plt.xlabel(r"$f(x)$")
plt.ylabel("density")
plt.show()


######################################################################
# The DQI Algorithm
# -----------------
# 
# Given the objective function presented earlier, a first approach might be to prepare the state
# :math:`\sum_{\mathbf{x}} f(\mathbf{x})|\mathbf{x}\rangle`. This would increase the probability of
# sampling :math:`\mathbf{x}` strings with high values of :math:`f(\mathbf{x})`. While this would
# work, DQI proposes a much more effective strategy to bias the sampling distribution and greatly
# enhance the probability of success. It proposes a smarter choice for the state by encoding a
# polynomial :math:`P(f(\mathbf{x}))` in the amplitudes:
# 
# .. math:: |P(f)\rangle=\sum_{\mathbf{x}} P(f(\mathbf{x}))|\mathbf{x}\rangle,
# 
# where :math:`P` is of degree :math:`l`. The challenge then becomes: how do we prepare such a state?
# DQI provides a concrete recipe.
# 
# The objective function :math:`f(\mathbf{x})` has a very sparse Hadamard spectrum. This means that
# there are only :math:`m` non-zero “frequency” components :math:`\mathbf{b_i}` out of :math:`2^n`
# possible in :math:`f(\mathbf{x})`. Consequently, preparing the state
# :math:`\sum_{\mathbf{x}} f(\mathbf{x})|\mathbf{x}\rangle` can be seen as a simple task by creating
# an appropriate superposition of the :math:`m` amplitudes and apply a Hadamard transform. The same
# principle holds for preparing :math:`|P(f)\rangle`, even though it is not as simple, we will still first
# prepare the Hadamard transform of the state, taking advantage of its sparse spectrum, and then
# transform back. The Hadamard transform of :math:`P(f(\mathbf{x}))` is:
# 
# .. math:: \sum_{k=0}^{l} \frac{w_k}{\sqrt{\binom{m}{k}}} \sum_{\substack{\mathbf{y}\\|\mathbf{y}|=k}} (-1)^{\mathbf{v}\cdot\mathbf{y}} |B^T \mathbf{y}\rangle,
# 
# where the coefficients :math:`w_k` are carefully chosen.
# 
# The DQI algorithm for solving the max-XORSAT problem involves three qubit registers: a weight, an
# error, and a syndrome register, with dimensions :math:`\left \lceil \log_{2} l\right \rceil`,
# :math:`m`, and :math:`n`, respectively. The algorithm’s steps are outlined below:
# 
# 1. **Embed weight coefficients:** prepare the state :math:`\sum_{k=0}^{l} w_k|k\rangle` in the
#    weight register to encode the degree :math:`l` of the polynomial.
# 2. **Prepare Dicke states:** generate Dicke states on the error register, conditioned on the value
#    :math:`k`,
# 
#    .. math:: \sum_{k=0}^l w_k|k\rangle \frac{1}{\sqrt{\binom{m}{k}}}\sum_{\substack{\mathbf{y}\\|\mathbf{y}|=k}} |\mathbf{y}\rangle.
# 
#    And subsequently, uncompute the weight register.
# 3. **Encode the vector of constrains:** encode :math:`\mathbf{v}` by imparting a phase
#    :math:`(-1)^{\mathbf{v}\cdot\mathbf{y}}`,
# 
#    .. math:: \sum_{k=0}^l w_k \frac{1}{\sqrt{\binom{m}{k}}}\sum_{\substack{\mathbf{y}\\|\mathbf{y}|=k}} (-1)^{\mathbf{v}\cdot\mathbf{y}} |\mathbf{y}\rangle.
# 4. **Compute syndrome:** reversibly compute :math:`B^T \mathbf{y}` into the syndrome register,
# 
#    .. math:: \sum_{k=0}^l w_k \frac{1}{\sqrt{\binom{m}{k}}}\sum_{\substack{\mathbf{y}\\|\mathbf{y}|=k}} (-1)^{\mathbf{v}\cdot\mathbf{y}} |\mathbf{y}\rangle|B^T \mathbf{y}\rangle.
# 5. **Decode and uncompute:** use the computed value of :math:`B^T \mathbf{y}` to find
#    :math:`\mathbf{y}` and uncompute the error register. This results in the Hadamard transform of
#    the desired state.
# 6. **Hadamard transform and sample:** apply the Hadamard transform to obtain :math:`|P(f)\rangle`
#    and sample from it to get solutions.
# 
# PennyLane implementation of DQI
# -------------------------------
# 
# Encode the polynomial degree :math:`l`
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# We are going to prepare the superposition :math:`\sum_{k=0}^{l} w_k|k\rangle`. As previously stated,
# the weight register is made up of :math:`\left \lceil \log_{2} l\right \rceil` qubits, which means
# that the index :math:`k` is being binary encoded. The coefficients :math:`w_k` are chosen such that
# they maximize the number of satisfied linear equations. The paper specifies that these optimal
# weights are the components of the principal eigenvector of an :math:`(l+1)\times(l+1)` symmetric
# tridiagonal matrix:
# 
# .. math::
# 
#     A^{(m,\ell,d)} = 
#    \begin{pmatrix}
#    0 & a_1 \\
#    a_1 & d & a_2 \\
#    & a_2 & 2d & \ddots \\
#    & & \ddots & \ddots & a_\ell \\
#    & & & a_\ell & \ell d
#    \end{pmatrix}
# 
# with :math:`a_k=\sqrt{k(m-k+1)}` and :math:`d=\frac{p-2r}{\sqrt{r(p-r)}}`. Here, :math:`p` is the
# number of elements of the finite field where our problem lives (in this case, :math:`p=2`), and
# :math:`r` is the number of inputs that will yield :math:`f=+1` (for this problem, :math:`r=1`). In
# this demo, we will use a polynomial of degree :math:`2` for a reason that will become clear during
# the decoding step. For now, you might be wondering if :math:`\left \lceil \log_{2} 2\right \rceil=1`
# qubit will be enough to encode :math:`k=0,1,2`. Well, let’s examine what we obtain for the
# coefficients :math:`\mathbf{w}`.
# 

p = 2
r = 1
d = (p - 2 * r) / pnp.sqrt(r * (p - r))
l = 2
# Define registers
weight_register = range(int(pnp.log2(l)))
m_register = range(1, m + 1)
n_register = range(m + 1, n + m + 1)


def w_k_optimal(m, l):
    """Calculates optimal weights for superposition: principal vector tridiagonal matrix."""
    diag_main = pnp.diag(pnp.arange(l + 1) * d)
    diag_sup = pnp.diag([pnp.sqrt(i * (m - i + 1)) for i in range(l)], 1)
    A = diag_main + diag_sup + pnp.transpose(diag_sup)
    eigenvalues, eigenvectors = pnp.linalg.eig(A)
    principal_index = pnp.argmax(eigenvalues)
    principal_vector = eigenvectors[:, principal_index]
    return principal_vector / pnp.linalg.norm(principal_vector)


w_k = w_k_optimal(m, l)
print("the optimal values for w are", w_k)


######################################################################
# Since :math:`w_0=0`, a single qubit is sufficient to encode the remaining non-zero coefficients. The
# explicit form of this state will be the uniform superposition
# :math:`\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)`, which can be readily prepared by a Hadamard gate.
# Let’s just keep in mind that the :math:`k` values we are encoding are :math:`1` and :math:`2` for
# subsequent steps.
# 
# Prepare Dicke states with :math:`k` excitations
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# For this step, we need a conditional operation that prepares Dicke states
# :math:`|D^{m}_{k}\rangle`-where the superscript is the number of qubits and the subscript is the
# number of excitations-for each index :math:`k` in the weight register. For our particular example,
# we will prepare Dicke states with one and two excitations.
# 
# Before implementing the conditional operation, let’s briefly review a method for preparing such
# states as presented in [#Bartschi2019]_. This deterministic algorithm provides a unitary
# :math:`U_{m,k}` to generate a Dicke state :math:`|D_k^m\rangle` from
# :math:`|0\rangle^{\otimes m-k}|1\rangle^{\otimes k}` as input. The method is based on the fact that
# Dicke states can be expressed in an inductive form as
# 
# .. math::  |D_l^m\rangle = \sqrt{\frac{l}{m}} |D_{l-1}^{m-1}\rangle \otimes |1\rangle + \sqrt{\frac{m-l}{m}} |D_{l}^{m-1}\rangle \otimes |0\rangle.
# 
# Given that decomposition, one can generate the two Dicke states on the right-hand side of the
# equation by applying a smaller unitary :math:`U_{m-1,k}` provided a superposition of the inputs
# :math:`|0\rangle^{\otimes m-l}|1\rangle^{\otimes l-1}` and
# :math:`|0\rangle^{\otimes m-l}|1\rangle^{\otimes l}` is prepared first. Following the paper’s
# convention, we define a *Split and Cyclic shift* unitary :math:`\mathrm{SCS}_{m,k}` to prepare the
# superposition of inputs.
# 
# .. math::  |0\rangle^{\otimes m-l}|1\rangle^{\otimes l} \rightarrow \sqrt{\frac{l}{m}} |0\rangle^{\otimes m-l}|1\rangle^{\otimes l} +  \sqrt{\frac{m-l}{m}} |0\rangle^{\otimes m-1-l}|1\rangle^{\otimes l}|0\rangle.
# 
# This recursive decomposition implies that :math:`U_{m,k}` can be implemented by applying
# :math:`\mathrm{SCS}_{m,k}` followed by the smaller unitary :math:`U_{m-1,k}`. This process
# continues; we keep decomposing the unitaries into a split and cycle operation followed by smaller
# unitary until we reach the base case :math:`U_{1,1}=\mathrm{Id}`. Ultimately, :math:`U_{m,k}` is
# composed of a series of subsequently smaller :math:`\mathrm{SCS}_{m,k}` opertions, as summarized by
# the following equation:
# 
# .. math:: U_{m,k} = \prod_{\ell=2}^{k} (\mathrm{SCS}_{\ell,\ell-1} \otimes \mathrm{Id}^{\otimes m-\ell})  \prod_{\ell=k+1}^{m} (\mathrm{Id}^{\otimes \ell-k-1} \otimes \mathrm{SCS}_{\ell,k} \otimes \mathrm{Id}^{\otimes m-\ell}).
# 
# The explicit form of :math:`\mathrm{SCS}_{m,k}`, which is implemented in code by the function
# ``SCS``, is not discussed here. However, it’s worth noting that it is composed of a two-qubit gate
# followed by :math:`k-1` three-qubit gates (further details can be found in [#Bartschi2019]_).
# Let’s now implement this algorithm in the ``prepare_dicke_state`` function. We will use it twice in
# a controlled way via ``qml.ctrl()`` in our main function ``DQI`` where all the parts of the DQI
# algorithm are going to be placed.
# 

def generate_bit_strings(length, hamming_weight):
    """Generates all bit strings of a given length and Hamming weight."""
    one_positions = itertools.combinations(range(length), hamming_weight)

    results = []
    for positions in one_positions:
        # Create a new list of zeros
        bit_string = [0] * length

        # Place 1s at the specified positions
        for pos in positions:
            bit_string[pos] = 1

        results.append(bit_string)

    return results


def SCS(m, k):
    """Implements the Split & Cycle shift unitary."""

    # Two-qubit gate
    qml.CNOT(wires=[m - 1, m])
    qml.CRY(2 * pnp.arccos(pnp.sqrt(1 / m)), wires=[m, m - 1])
    qml.CNOT(wires=[m - 1, m])

    # k-1 three-qubit gates
    for l in range(2, k + 1):
        qml.CNOT(wires=[m - l, m])
        qml.ctrl(qml.RY, (m, m - l + 1))(2 * pnp.arccos(pnp.sqrt(l / m)), wires=m - l)
        qml.CNOT(wires=[m - l, m])


def prepare_dicke_state(m, k):
    """Prepares a Dicke state with m qubits and k excitations in a inductive form."""

    # Prepares input state
    for wire_idx in range(m - k + 1, m + 1):
        qml.X(wires=wire_idx)

    # Applies the SCS unitaries
    for i in reversed(range(k + 1, m + 1)):
        SCS(i, k)
    for i in reversed(range(2, k + 1)):
        SCS(i, i - 1)


dev = qml.device("default.qubit", wires=range(0, 1 + m + n), shots=n_samples)


@qml.qnode(dev)
def DQI(m, n, l):
    """Quantum circuit implementing DQI algorithm to solve max-XORSAT."""

    # Prepare weight register
    qml.Hadamard(wires=0)

    # Prepare Dicke states conditioned on k values
    qml.ctrl(prepare_dicke_state, (0), control_values=0)(m, 1)
    qml.ctrl(prepare_dicke_state, (0), control_values=1)(m, 2)

    # Uncompute weight register
    bit_strings = generate_bit_strings(m, l)
    for i in range(math.comb(m, l)):
        qml.ctrl(qml.X, m_register, control_values=bit_strings[i])(0)

    return qml.counts(wires=range(0, m + 1))


print(DQI(m, n, l))


######################################################################
# After preparing the Dicke states, we uncompute and discard the state of the weight register. In
# general, this is a straightforward process, as the Hamming weights encoded are known. In our
# approach, we accomplished this by generating bit strings of length :math:`m` with Hamming weight of
# :math:`2` using the ``generate_bit_strings`` function. We then applied a controlled bit flip to the
# weight register for these specific cases. We did not need to perform any action for bit strings with
# a Hamming weight of :math:`1`, as the qubit state was already :math:`|0\rangle`. As the output in
# this step demonstrates, the Dicke states were prepared, and the weight register was successfully
# uncomputed. From now on, we will discard it and not include it in our outputs.
# 
# Encode constrains vector
# ~~~~~~~~~~~~~~~~~~~~~~~~
# 
# To impart a phase :math:`(-1)^{\mathbf{v}\cdot\mathbf{y}}`, we perform a Pauli-Z on each qubit for
# which :math:`v_i=1`, as instructed by the DQI paper. This is simply a conditional operation within a
# ``for`` loop in the ``phase_Z`` function. Let’s now include this step in the ``DQI`` function and
# output the resulting quantum state.
# 

def phase_Z(v):
    """Imparts a phase (-1)^{vy}."""
    for i in range(len(v)):
        if v[i] == 1:
            qml.Z(wires=i + 1)


dev = qml.device("default.qubit", wires=range(0, 1 + m + n))


@qml.qnode(dev)
def DQI(m, n, l):
    """Quantum circuit implementing DQI algorithm to solve max-XORSAT."""

    # Prepare weight register
    qml.Hadamard(wires=0)

    # Prepare Dicke states conditioned on k values
    qml.ctrl(prepare_dicke_state, (0), control_values=0)(m, 1)
    qml.ctrl(prepare_dicke_state, (0), control_values=1)(m, 2)

    # Uncompute weight register
    bit_strings = generate_bit_strings(m, l)
    for i in range(math.comb(m, l)):
        qml.ctrl(qml.X, m_register, control_values=bit_strings[i])(0)

    # Impart phase
    phase_Z(v)

    return qml.state()


results = DQI(m, n, l)
nonzero_index = pnp.nonzero(results)  # Select non-zero state components
print(results[nonzero_index])


######################################################################
# Encode matrix B in the syndrome register
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# We are almost there, hang on! Now, we need to compute :math:`B^T \mathbf{y}` in the syndrom
# register. While it may not be immediately obvious how to implement this as a unitary operation, the
# binary nature of the matrix and vector allows for a smooth translation. This operation can be
# realized using CNOT gates, with controls on the error register and targets on the syndrome register
# [#Patamawisut2025]_. Specifically, a CNOT is applied for every entry :math:`B_{ij}^T=1`, controlled on the
# :math:`j`-th qubit of the error register and with the :math:`i`-th qubit of the syndrome register as
# the target.
# 

def B_T_multiplication(B_T, n_register):
    """Computes B^T y into the syndrome register."""
    for row_index, row in enumerate(B_T):
        for col_index, element in enumerate(row):
            if element == 1:
                qml.CNOT(wires=[m_register[col_index], n_register[row_index]])


dev = qml.device("default.qubit", wires=range(0, 1 + m + n), shots=n_samples)


@qml.qnode(dev)
def DQI(m, n, l):
    """Quantum circuit implementing DQI algorithm to solve max-XORSAT."""

    # Prepare weight register
    qml.Hadamard(wires=0)

    # Prepare Dicke states conditioned on k values
    qml.ctrl(prepare_dicke_state, (0), control_values=0)(m, 1)
    qml.ctrl(prepare_dicke_state, (0), control_values=1)(m, 2)

    # Uncompute weight register
    bit_strings = generate_bit_strings(m, l)
    for i in range(math.comb(m, l)):
        qml.ctrl(qml.X, m_register, control_values=bit_strings[i])(0)

    # Impart phase
    phase_Z(v)

    # Compute s = B^T y in to the syndrome register
    B_T_multiplication(B_T, n_register)

    return qml.counts(wires=range(1, m + n + 1))


print(DQI(m, n, l))


######################################################################
# Decoding!!
# ~~~~~~~~~~
# 
# This step is the main challenge of the algorithm: uncomputing the error register :math:`\mathbf{y}`
# using the information from the syndrome register :math:`\mathbf{s}=B^T \mathbf{y}` in an efficient
# way. This would be an easy task if :math:`B` were always a square matrix; however, since it is not,
# we need to solve an undetermined linear system of equations :math:`\mathbf{s}=B^T \mathbf{y}`
# subject to the constraint :math:`|\mathbf{y}|\leq l` given by the known Hamming weights of
# :math:`\mathbf{y}`. The problem we have just described is precisely the **syndrome decoding
# problem**, where :math:`B^T` is the parity-check matrix, :math:`\mathbf{s}` is the syndrome, and
# :math:`\mathbf{y}` is the error.
#
# .. admonition:: Polynomial degree :math:`l`
#     :class: note
#
#     The kernel of :math:`B^T` defines an error-correcting code. The distance :math:`d` of this code determines the number of errors
#     it can correct, given by :math:`\left \lfloor (d-1)/2 \right \rfloor`. This condition ensures that the decoding problem has a unique solution.
#     For this demo, we choose :math:`l` such that it is less than half the distance of the code and this condition is met.
#     For a detailed discussion of the restrictions on :math:`l`, please refer to the original paper [#Jordan2024]_. 
# 
# To keep things simple, we will use a brute-force approach for decoding by building a Lookup Table
# (LUT) in which we compute the syndrome for each possible error using the classical function
# ``syndrome_LUT``. Then, for each syndrome in the syndrome register, the corresponding error is
# uncomputed in the error register using controlled bit-flip operations. We will now integrate this
# into our\ ``DQI`` function and see in the output how the syndrome register is uncomputed.
# 

def syndrome_LUT(parity_check_matrix_T):
    """Generates the Lookup table given a parity-check matrix."""
    num_data_qubits = parity_check_matrix_T.shape[1]
    syndrome_dict = {}

    for i in range(2**num_data_qubits):
        error_bitstring = format(i, f"0{num_data_qubits}b")
        error_vector = pnp.array([int(bit) for bit in error_bitstring])

        syndrome_vector = pnp.dot(parity_check_matrix_T, error_vector) % 2
        syndrome_bitstring = "".join(map(str, syndrome_vector))

        if syndrome_bitstring not in syndrome_dict:
            syndrome_dict[syndrome_bitstring] = error_bitstring
        else:
            existing_error = syndrome_dict[syndrome_bitstring]
            if pnp.sum(error_vector) < pnp.sum(pnp.array([int(bit) for bit in existing_error])):
                syndrome_dict[syndrome_bitstring] = error_bitstring

    # Convert the dictionary to the desired list-of-lists format
    lookup_matrix = []
    for syndrome_str, error_str in syndrome_dict.items():
        syndrome_list = [int(bit) for bit in syndrome_str]
        error_list = [int(bit) for bit in error_str]
        lookup_matrix.append([syndrome_list, error_list])

    # Sort the matrix for a consistent output (e.g., by syndrome)
    lookup_matrix.sort(key=lambda x: int("".join(map(str, x[0])), 2))

    return lookup_matrix


# Generate the lookup table
decoding_table = syndrome_LUT(B_T)

dev = qml.device("default.qubit", wires=range(0, 1 + m + n), shots=1000)


@qml.qnode(dev)
def DQI(m, n, l):
    """Quantum circuit implementing DQI algorithm to solve max-XORSAT."""

    # Prepare weight register
    qml.Hadamard(wires=0)

    # Prepare Dicke states conditioned on k values
    qml.ctrl(prepare_dicke_state, (0), control_values=0)(m, 1)
    qml.ctrl(prepare_dicke_state, (0), control_values=1)(m, 2)

    # Uncompute weight register
    bit_strings = generate_bit_strings(m, l)
    for i in range(math.comb(m, l)):
        qml.ctrl(qml.X, m_register, control_values=bit_strings[i])(0)

    # Impart phase
    phase_Z(v)

    # Compute s = B^T y in to the syndrome register
    B_T_multiplication(B_T, n_register)

    # Uncompute syndrome register using a Lookup table
    for row in decoding_table:
        syndrome, error = row
        for i in range(len(error)):
            if error[i] == 1:
                qml.ctrl(qml.X, n_register, control_values=syndrome)(m_register[i])

    return qml.counts(wires=range(1, m + n + 1))


print(DQI(m, n, l))


######################################################################
# Hadamard transform and sample
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# After the previous step, we obtained the Hadamard transform of the state were looking for. The final
# step is to apply the Hadamard transform to this state to obtain
# :math:`|P(f)\rangle=\sum_{\mathbf{x}} P(f(\mathbf{x}))|\mathbf{x}\rangle`. Finally, we will collect
# samples from such state, calculate their objective functions and build a histogram to compare with
# the random sampling done af first.
# 

dev = qml.device("default.qubit", wires=range(0, 1 + m + n), shots=n_samples)


@qml.qnode(dev)
def DQI(m, n, l):
    """Quantum circuit implementing DQI algorithm to solve max-XORSAT."""

    # Prepare weight register
    qml.Hadamard(wires=0)

    # Prepare Dicke states conditioned on k values
    qml.ctrl(prepare_dicke_state, (0), control_values=0)(m, 1)
    qml.ctrl(prepare_dicke_state, (0), control_values=1)(m, 2)

    # Uncompute weight register
    bit_strings = generate_bit_strings(m, l)
    for i in range(math.comb(m, l)):
        qml.ctrl(qml.X, m_register, control_values=bit_strings[i])(0)

    # Impart phase
    phase_Z(v)

    # Compute s = B^T y in to the syndrome register
    B_T_multiplication(B_T, n_register)

    # Uncompute syndrome register using a Lookup table
    for row in decoding_table:
        syndrome, error = row
        for i in range(len(error)):
            if error[i] == 1:
                qml.ctrl(qml.X, n_register, control_values=syndrome)(m_register[i])

    # Apply Hadamard transform
    for wire in n_register:
        qml.Hadamard(wire)

    return qml.counts(wires=n_register)


results = DQI(m, n, l)
all_bit_lists = []
for string, samples in results.items():
    integer_list = [int(bit) for bit in string]
    for _ in range(samples):
        all_bit_lists.append(integer_list)

DQI_array = pnp.array(all_bit_lists)  # DQI sample array

f_x_array_DQI = [objective_function(DQI_array[i]) for i in range(n_samples)]

print(results)
plt.figure(figsize=(3, 2))
plt.hist(f_x_array_random, bins=30, alpha=0.7, density=True, label="random sampling")
plt.hist(f_x_array_DQI, bins=30, alpha=0.5, density=True, label="DQI sampling")
plt.xlabel(r"$f(x)$")
plt.ylabel("density")
plt.legend(prop={"size": 7})
plt.show()


######################################################################
# The histogram shows a significantly higher probability of obtaining a bit string with a high
# objective value when sampling from the DQI algorithm compared to uniform sampling. It is also worth
# noting that the samples produced by DQI are unbiased, meaning that the probability is uniform for
# all solutions within a given objective value.
# 
# Conclusion
# ----------
# 
# In this tutorial, we implemented the Decoded Quantum Interferometry algorithm to solve the
# max-XORSAT problem. We’ve shown how DQI recasts a combinatorial optimization task as a
# decoding problem by leveraging quantum interference and encoding a polynomial of the objective
# function in the amplitudes of a quantum state. While we used a simplified problem here, the
# principles we’ve explored are applicable to more complex optimization tasks. This algorithm marks
# the beginning of an exploration into a different approach for achieving quantum speedups.
# 
# References
# -----------
#
# .. [#Jordan2024]
#    Stephen P. Jordan, Noah Shutty, Mary Wootters, Adam Zalcman, Alexander Schmidhuber, Robbie King, Sergei V. Isakov, Tanuj Khattar, and Ryan Babbush.
#    "Optimization by Decoded Quantum Interferometry.",
#    `<https://arxiv.org/abs/2408.08292>`__, 2024.
#
# .. [#Bartschi2019]
#    Andreas Bärtschi, and Stephan Eidenbenz.
#    "Deterministic Preparation of Dicke States.",
#    `<https://arxiv.org/abs/1904.07358>`__, 2019.
#
# .. [#Patamawisut2025]
#    Natchapol Patamawisut, Naphan Benchasattabuse, Michal Hajdušek, and Rodney Van Meter.
#    "Quantum Circuit Design for Decoded Quantum Interferometry."
#    `<https://arxiv.org/abs/2504.18334>`__, 2025.
