r"""Lie algebra simulation techniques
=====================================

Abstract

Introduction
------------

Lie algebra theory is tightly connected to quantum physics [#Kottmann]_.
While Lie algebra theory is an integral part of high energy and condensed matter physics,
recent developments have shown connections to quantum simulation and quantum computing.
In particular, the infamous barren plateau problem has been fully characterized by the underlying
`Dynamical Lie Algebra (DLA)<https://pennylane.ai/qml/demos/tutorial_liealgebra/>`__ [#Fontana]_ [#Ragone]_.
The main result of these works is that the circuit's DLA is inversely proportional to the variance of the mean of the gradient
(over a uniform parameter distribution), leading to exponentially vanishing gradients in the uniform average case whenever the 
DLA scales exponentially in system size.

At the same time, there exist Lie algebraic techniques with which one can classically simulate circuits with a complexity polynomial
in the dimension of the circuit's DLA [#Galitski]_ [#Goh]_.
In particular, this means that circuits with guaranteed non-exponentially vanishing gradients in the uniform average case are classically simulable,
leading to some debate on whether the field of variational quantum computing is doomed or not [#Cerezo]_.
The majority of DLAs are in fact exponentially sized [#Wiersema]_, shifting this debate towards the question of whether or not uniform average case results
are relevant in practice for variational methods [#Mazzola]_, with some argueing for better initialization methods [#Park]_.

In this demo, we want to focus on the niche cases where efficient classical simulation is possible due to polynomially sized DLAs.
This mainly concerns DLAs of the transverse field Ising model and variations thereof.

Lie algebra basics
------------------

Before going into the specifics of Lie algebra simulation (Lie-sim or :math:`\mathfrak{g}`-sim),
we want to briefly recap the most important concepts of Lie algebra theory that is relevant for us. A more thorough intro with the connections to
quantum physics highlighted can be found in our `Intro to (Dynamical) Lie Algebras for quantum practitioners <https://pennylane.ai/qml/demos/tutorial_liealgebra/>`__.

Given skew-Hermitian operators :math:`G = \{h_i\}` (think, Hermitian observables like terms of a Hamiltonian),
the dynamical Lie algebra :math:`\mathfrak{g}`
can be computed via the Lie closure :math:`\langle \cdot \rangle_\text{Lie}` (see :func:`~lie_closure`),

.. math:: \mathfrak{g} = \langle \{h_i\} \rangle_\text{Lie} \subseteq \mathfrak{su}(2^n).

That is, computing all possible nested commutators until no new operators emerge. This leads to a set of operators that is closed under commutations,
hence the name.
In particular, the result of the commutator between any two elements in :math:`\mathfrak{g}`
can be decomposed as a linear combination of other elements in :math:`\mathfrak{g}`,

.. math:: [h_\alpha, h_\beta] = \sum_\gamma f^\gamma_{\alpha \beta} h_\gamma.

The coefficients :math:`f^\gamma_{\alpha \beta}` are called the structure constants of the DLA and can be computed via standard
projection in linear vector spaces (as is :math:`i\mathfrak{g}`),

.. math:: f^\gamma_{\alpha \beta} = \frac{\langle h_\gamma, [h_\alpha, h_\beta]\rangle}{\langle h_\gamma, h_\gamma\rangle}.

The main difference from the usual vector spaces like :math:`\mathbb{R}^n` or :math:`\mathbb{C}^n` is that here we 
use the trace inner product between operators :math:`\langle h_\alpha, h_\beta \rangle = \text{tr}\left[h_\alpha^\dagger h_\beta \right]/2^n`

Lie-sim
-------

mhmhmh identity
~~~~~~~~~~~~~~~

In Lie-sim, we are interested in how expectation values of Lie algebra elements are transformed under unitary evolution.
For that, we look at an expectation vector :math:`\vec{e}` made up of expectation values with respect to some transformed initial state `\rho`,

.. (\vec{e})_\alpha = \text{tr}\left[ h_\alpha U \rho U^\dagger \right] = \text{tr}\left[ U^\dagger h_\alpha U \rho \right].

In the second step we used the cyclic property of the trace, leaving us with the question of how DLA elements are transformed under :math:`U`.
In the context of Lie-sim, we assume the unitary to be generated by DLA elements :math:`h_\mu \in \mathfrak{g}`, in particular we have

.. U = e^{-i \theta h_\mu}.

As a consequence of the `Baker-Campbell-Hausdorff formula <https://en.wikipedia.org/wiki/Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula>`__,
we know that the any :math:`h_\mu \in \mathfrak{g}` transformed under such a :math:`U` is again in :math:`\mathfrak{g}`.
In fact, it is a well-known result that the resulting operator is given by the exponential of the structure constants

.. math:: e^{i \theta h_\gamma} h_\alpha e^{-i \theta h_\mu} = \sum_\beta e^{\theta f^\gamma_{\alpha \beta}} h_\beta.

This is the mhmhmh identity that can be summarized as

.. math:: \text{Ad}_{e^{ih_\mu}} = e^{i \text{ad}_{h_\mu}}

where the adjoint action of the Lie group, :math:`\text{Ad}_{e^{ih_\mu}}(\cdot) = e^{ih_\mu} \cdot e^{-ih_\mu}`, is related to the
adjoint representation :math:`\left(\text{ad}_{h_\mu}\right)_{\alpha \beta} = f^\mu_{\alpha \beta}` of the associated Lie algebra.

Expectation value evolution
~~~~~~~~~~~~~~~~~~~~~~~~~~~

We are interested in expectation values of observables composed of DLA elements, i.e.

.. math:: \langle \hat{O} \rangle = \text{tr}\left[\hat{O} \mathcal{U} \rho_0 \mathcal{U}^\dagger \right]

with :math:`\langle \hat{O} \rangle = \sum_\alpha \omega_\alpha h_\alpha` with some unitary evolution of a parametrized quantum circuit

.. math:: \mathcal{U} = \prod_j e^{-i \theta_j h_j},

generated by DLA elements.
Using the mhmhmh identity, we see that this is equivalent to evolving the expectation vector :math:`\vec{e}` by the adjoint representation of that circuit,

.. math:: \tilde{U} = \prod_j e^{\theta_j \text{ad}_{h_j}}.

The dimension of :math:`\left(\text{ad}_{h_j}\right)_{\alpha \beta} = f^j_{\alpha \beta}` is
`\text{dim}(\mathfrak{g}) \times \text{dim}(\mathfrak{g})`. So while we evolve a :math:`2^n`-dimensional
complex vectors in state vector simulators, we evolve a :math`\text{dim}(\mathfrak{g})`-dimensional expectation
vector in Lie-sim, which is more efficient whenever :math:`\text{dim}(\mathfrak{g}) \le 2^n`. And, in particular, generally efficient, 
whenever :math`\text{dim}(\mathfrak{g}) = \mathcal{O}\left(\text{poly}(n)\right)`.

Lie-sim in PennyLane
--------------------

Let us put this into practice and write a differentiable Lie-simulator in PennyLane.
We start with some boilerplate PennyLane imports.

"""

import pennylane as qml
from pennylane import X, Y, Z, I
from pennylane.pauli import PauliSentence, PauliWord, PauliVSpace
import numpy as np

import jax
import jax.numpy as jnp
from jax.scipy.linalg import expm

jax.config.update("jax_enable_x64", True)
jax.config.update("jax_platform_name", "cpu")

def exppw(theta, ps):
    # assert that it is indeed a pure pauli word, not a sentence
    assert (len(ps) == 1 and isinstance(ps, PauliSentence)) or isinstance(ps, PauliWord)
    return np.cos(theta) * PauliWord({}) + 1j * np.sin(theta) * ps

##############################################################################
#
# System DLA
# ~~~~~~~~~~
#
# As mentioned before, polynomially sized DLAs are rare with the transverse field Ising model (TFIM) with nearest neighbors being one of them.
# We take for simplicity the one dinemsional variant and define its generators and compute the :func:`~lie_closure` :math:`\{h_\alpha\}`.

n = 10 # number of qubits.
generators = [
    X(i) @ X(i+1) for i in range(n-1)
]
generators += [
    Z(i) for i in range(n)
]
generators = [op.pauli_rep for op in generators] # work with PauliSentence instances for better efficiency

dla = qml.pauli.lie_closure(generators, pauli=True)
dim_g = len(dla)

##############################################################################
# We are using the :class:`~pennylane.pauli.PauliSentence` representation of the ops for more efficient arithmetic and processing.
#
# Initial expectation vector
# ~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# With that, we can compute the initial expectation vector for the :math:`\rho_0 = |0 \rangle \langle 0 |` initial state for every DLA element.
# We are doing a trick of representing the initial state as a Pauli operator, :math:`|0 \rangle \langle 0 |^{\Otimes n} = \sum_{i=1}^n (I_i + Z_i)_2`,
# and use the analytic trace method :meth:`~pennylane.pauli.PauliSentence.trace`, all to avoid having to go to the full Hilbert space.

# compute initial expectation vector
e_in = jnp.zeros(dim_g, dtype=float)

# initial state |0x0| = I + Z, note that trace function below normalizes by the dimension already
rho_in = qml.sum(*(I(i) + Z(i) for i in range(n)))
rho_in = rho_in.pauli_rep

for i, h_i in enumerate(dla):
    expectation_h_alpha = (h_i @ rho_in).trace()
    e_in = e_in.at[i].set(expectation_h_alpha)

e_in = jnp.array(e_in)
e_in


##############################################################################
# Observable
# ~~~~~~~~~~
#
# We can compute the expectation value of any linear combination of DLA elements. We choose the TFIM Hamiltonian itself,
#
# .. math:: \hat{O} = H_\text{TFIM} = \sum_j J X_j X_{j+1} + h Z_i.
#
# So just the generators with some coefficient, here, for simplicity, :math:`J=h=0.5`.

weights = jnp.zeros(dim_g, dtype=float)
weights = weights.at[:len(generators)].set(0.5)

##############################################################################
# Forward and backward pass
# ~~~~~~~~~~~~~~~~~~~~~~~~~
#
# Together with the structure constants computed via :func:`~structure_constants` we now have all ingredients to define
# the forward pass of the expectation value computation. For demonstration purposes,
# we choose a random subset of ``depth=10`` generators for gates from the DLA.

adjoint_repr = qml.pauli.structure_constants(dla)

depth = 10
gate_choice = np.random.choice(dim_g, size=depth)
gates = adjoint_repr[gate_choice]

def forward(coeffs, weights):
    # simulation
    e_t = e_in
    for i in range(depth):
        e_t = expm(coeffs[i] * gates[i]) @ e_t

    # final expectation value
    result_g_sim = weights @ e_t

    return result_g_sim.real

coeffs = jax.random.normal(jax.random.PRNGKey(0), shape=(10,))

forward(coeffs, weights), jax.grad(forward)(coeffs, weights)

##############################################################################
# As a sanity check, we compare the computation with the full state vector equivalent circuit.

H = 0.5 * qml.sum(*[op.operation() for op in generators])

@qml.qnode(qml.device("default.qubit"), interface="jax")
def qnode(coeffs):
    for i, mu in enumerate(gate_choice):
        qml.exp(
            -1j * coeffs[i] * dla[mu].operation()
        )
    return qml.expval(H)

qnode(coeffs), jax.grad(qnode)(coeffs)


##############################################################################
# We see that both simulation yield the same results, while full state vector simulation is done with a
# :math:`2^n = 1024` dimensional state vector, and Lie-sim with a :math:`\text{dim}(g) = 2n (2n-1)/2 = 190` dimensional
# expectation vector.

import matplotlib.pyplot as plt
ns = np.arange(2, 17)

plt.plot(ns, 2*ns*(2*ns-1)/2, "x-", label="dim(g)")
plt.plot(ns, 2**ns, ".-", label="2^n")
plt.yscale("log")
plt.legend()
plt.xlabel("n qubits")
plt.show()


# Some application? E.g. some adapted variant of QAOA
# (adapted in the sense that the mixer Hamiltonian might not be feasible with DLA elements, but perhaps something similar can be constructed)


##############################################################################
# 
# Conclusion
# ----------
#
# We learned about the conceptually intriguing connection between unitary evolution and the adjoint representation of the system DLA via the mhmhmh identity,
# and saw how this can be used for classical simulation. In particular, for specific systems like the TFIM we can efficiently simulate circuit 
# expectation values.
#



##############################################################################
# 
# References
# ----------
#
# .. [#Kottmann]
#
#     Korbinian Kottmann
#     "Introducing (Dynamical) Lie Algebras for quantum practitioners"
#     `PennyLane Demos <https://pennylane.ai/qml/demos/tutorial_liealgebra/>`__, 2024.
#
# .. [#Fontana]
#
#     Enrico Fontana, Dylan Herman, Shouvanik Chakrabarti, Niraj Kumar, Romina Yalovetzky, Jamie Heredge, Shree Hari Sureshbabu, Marco Pistoia
#     "The Adjoint Is All You Need: Characterizing Barren Plateaus in Quantum Ansätze"
#     `arXiv:2309.07902 <https://arxiv.org/abs/2309.07902>`__, 2023.
#
# .. [#Ragone]
#
#     Michael Ragone, Bojko N. Bakalov, Frédéric Sauvage, Alexander F. Kemper, Carlos Ortiz Marrero, Martin Larocca, M. Cerezo
#     "A Unified Theory of Barren Plateaus for Deep Parametrized Quantum Circuits"
#     `arXiv:2309.09342 <https://arxiv.org/abs/2309.09342>`__, 2023.
#
# .. [#Galitski]
#
#     Victor Galitski
#     "Quantum-to-Classical Correspondence and Hubbard-Stratonovich Dynamical Systems, a Lie-Algebraic Approach"
#     `arXiv:1012.2873 <https://arxiv.org/abs/1012.2873>`__, 2010.
#
# .. [#Goh]
#
#     Matthew L. Goh, Martin Larocca, Lukasz Cincio, M. Cerezo, Frédéric Sauvage
#     "Lie-algebraic classical simulations for variational quantum computing"
#     `arXiv:2308.01432 <https://arxiv.org/abs/2308.01432>`__, 2023.
#
# .. [#Cerezo]
#
#     M. Cerezo, Martin Larocca, Diego García-Martín, N. L. Diaz, Paolo Braccia, Enrico Fontana, Manuel S. Rudolph, Pablo Bermejo, Aroosa Ijaz, Supanut Thanasilp, Eric R. Anschuetz, Zoë Holmes
#     "Does provable absence of barren plateaus imply classical simulability? Or, why we need to rethink variational quantum computing"
#     `arXiv:2312.09121 <https://arxiv.org/abs/2312.09121>`__, 2023.
#
# .. [#Wiersema]
#
#     Roeland Wiersema, Efekan Kökcü, Alexander F. Kemper, Bojko N. Bakalov
#     "Classification of dynamical Lie algebras for translation-invariant 2-local spin systems in one dimension"
#     `arXiv:2309.05690 <https://arxiv.org/abs/2309.05690>`__, 2023.
#
# .. [#Mazzola]
#
#     Guglielmo Mazzola
#     "Quantum computing for chemistry and physics applications from a Monte Carlo perspective"
#     `arXiv:2308.07964 <https://arxiv.org/abs/2308.07964>`__, 2023.
#
# .. [#Park]
#
#     Chae-Yeun Park, Minhyeok Kang, Joonsuk Huh
#     "Hardware-efficient ansatz without barren plateaus in any depth"
#     `arXiv:2403.04844 <https://arxiv.org/abs/2403.04844>`__, 2024.
#

##############################################################################
# About the author
# ----------------
# .. include:: ../_static/authors/korbinian_kottmann.txt
